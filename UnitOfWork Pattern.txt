# INTRO
-------
- Unit of Work is the concept related to the effective implementation of the Repository Pattern.
- A Repository is nothing but a class defined for an entity, with all the operations possible on the specific entity.
- Unit of Work is referred to as a single transaction that involves multiple operations of insert/update/delete and so on.


# Without UnitOfWork
--------------------
 
      Order Controller <----------------------------> OrderRepository with its own _dbContext
      Customer Controller <-------------------------> CustomerRepository with its own _dbContext

# With UnitOfWork
-----------------

      Order Controller <---------  UnitOfWork Class          --------> OrderRepository with its own _dbContext
      Customer Controller <-----   relays DbContext instance --------> CustomerRepository with its own _dbContext

# Implementation
----------------

1- Add the interface to domain layer and implement IDisposable interface
2- Add all repositories as a props in the interface
3- Add all context method that you need 

   - Domain/Core Layer -> 
     public interface IUnitOfWork : IDisposable
     {
       IRepository<Order> Orders {get;}
       IRepository<Customer> Customers {get;}

       int SaveChanges();
     }
4- Add class to infrasturcture layer and implement the interface

   - Infrasturcture Layer ->
     public class UnitOfWork : IUnitOfWork
     {
         
     }
5- Inject the Context by constructor injection

     public class UnitOfWork : IUnitOfWork
     {
         private readonly AppDbContext _context;

         public UnitOfWork(AppDbContext context)
         {
            _context = context;
         }
     }
 
6- Add All Repositories as Properties and initialize them

     public class UnitOfWork : IUnitOfWork
     {
         private readonly AppDbContext _context;
  
         public IRepository<Order> Orders {get; private set;}
         public IRepository<Customer> Customers {get; private set;}


         public UnitOfWork(AppDbContext context)
         {
            _context = context;
            Orders = new Repository<Order>(_context);
            Customers = new Repositories<Customer>(_context);
         }
     }

7- Complete IUnitOfWork implementation, by adding int SaveChanges() method body


     public class UnitOfWork : IUnitOfWork
     {
         private readonly AppDbContext _context;
  
         public IRepository<Order> Orders {get; private set;}
         public IRepository<Customer> Customers {get; private set;}


         public UnitOfWork(AppDbContext context)
         {
            _context = context;
            Orders = new Repository<Order>(_context);
            Customers = new Repositories<Customer>(_context);
         }

         public int SaveChanges()
         {
           return _context.SaveChanges();
         }
     }


8- Don't forget to implement IDisposble interface


     public class UnitOfWork : IUnitOfWork
     {
         private readonly AppDbContext _context;
  
         public IRepository<Order> Orders {get; private set;}
         public IRepository<Customer> Customers {get; private set;}


         public UnitOfWork(AppDbContext context)
         {
            _context = context;
            Orders = new Repository<Order>(_context);
            Customers = new Repositories<Customer>(_context);
         }

         public int SaveChanges()
         {
           return _context.SaveChanges();
         }

         public void Dispose()
         {
           _context.Dispose();
         }
     }


9- Replace builder.Services.AddTransient(typeof(IRepository<>),typeof(Repository<>));
    by     builder.Services.AddTransient<IUnitOfWork, UnitOfWork>();

10- In each controller we will inject IUnitOfWork _unitOfWork; instead of IRepository "Constructor Injection"

11- Replace _unitOfWrok.Orders.GetById(1); instead of _orderRepository.GetById(1);
   "Replace in all controllers with specified property"



















